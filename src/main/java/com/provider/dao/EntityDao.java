package com.provider.dao;

import com.provider.dao.exception.DBException;
import com.provider.entity.Entity;
import com.provider.entity.EntityFactory;
import com.provider.entity.SimpleEntityFactory;
import com.provider.util.Checks;
import org.jetbrains.annotations.NotNull;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Optional;

/**
 * DAO pattern main ancestor. All DAOs must extend this class.
 * Before performing DAO operations setConnection must be called.
 * DAOs must never close obtained connection object.
 * @param <K> table primary key
 * @param <T> entity class
 */
public abstract class EntityDao<K, T extends Entity> {
    /**
     * Connection used by DAOs
     */
    protected Connection connection;

    /**
     * Entity factory used by DAOs
     */
    protected final EntityFactory entityFactory = SimpleEntityFactory.newInstance();

    /**
     * Sets jdbc connection
     * @param connection jdbc connection
     */
    public void setConnection(@NotNull Connection connection) {
        this.connection = connection;
    }

    /**
     * Sets connection field to null
     */
    public void resetConnection() {
        this.connection = null;
    }

    /**
     * Finds entity by key
     * @param key entity table key, most often - Integer or Long
     * @return optional containing entity if found, empty optional otherwise
     */
    public abstract @NotNull Optional<T> findByKey(@NotNull K key) throws DBException;

    /**
     * Inserts entity. Updates object's id field according to id generated by the database.
     * @param entity - entity to be inserted
     * @return true if any changes to db were made
     * @throws DBException if SQLException occurred
     */
    public abstract boolean insert(@NotNull T entity) throws DBException;

    /**
     * Generic method that allows to find one record in db
     * May be used when implementing <code>findByKey</code> method
     * @param sqlRequest request for prepared statement(containing one '?')
     * @param key id value
     * @return optional containing a record if found
     * @throws DBException if SQLException occurred
     */
    protected final Optional<T> findByKey(@NotNull String sqlRequest, int key) throws DBException {
        Checks.throwIfInvalidId(key);
        try (var preparedStatement = connection.prepareStatement(sqlRequest)) {
            preparedStatement.setInt(1, key);
            final ResultSet resultSet = preparedStatement.executeQuery();
            if (resultSet.next()) {
                return Optional.of(fetchOne(resultSet));
            }
        } catch (SQLException ex) {
            throw new DBException(ex);
        }
        return Optional.empty();
    }

    /**
     * Generic method that allows to find one record in db
     * May be used when implementing <code>findByKey</code> method
     * @param sqlRequest request for prepared statement(containing one '?')
     * @param key id value
     * @return optional containing a record if found
     * @throws DBException if SQLException occurred
     */
    protected final Optional<T> findByKey(@NotNull String sqlRequest, long key) throws DBException {
        Checks.throwIfInvalidId(key);
        try (var preparedStatement = connection.prepareStatement(sqlRequest)) {
            preparedStatement.setLong(1, key);
            final ResultSet resultSet = preparedStatement.executeQuery();
            if (resultSet.next()) {
                return Optional.of(fetchOne(resultSet));
            }
        } catch (SQLException ex) {
            throw new DBException(ex);
        }
        return Optional.empty();
    }

    /**
     * Extracts one record from a result set
     * @param resultSet result set pointing to a valid record
     * @return extracted entity
     * @throws DBException if SQLException is thrown
     */
    protected abstract @NotNull T fetchOne(@NotNull ResultSet resultSet) throws DBException;
}
