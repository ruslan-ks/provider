--DROP DATABASE IF EXISTS provider;
--CREATE DATABASE provider;
--COMMENT ON DATABASE provider IS 'Java internet provider project database';

\c provider;

BEGIN;

--------------------- translation schema --------------------------------------

DROP SCHEMA IF EXISTS translation CASCADE;
CREATE SCHEMA translation;

DROP TABLE IF EXISTS translation.languages CASCADE;
CREATE TABLE translation.languages(
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    short_name TEXT UNIQUE NOT NULL
);

DROP TABLE IF EXISTS translation.text_content CASCADE;
CREATE TABLE translation.text_content(
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    original_language_id INT NOT NULL,
    original_text TEXT NOT NULL
        CONSTRAINT valid_original_text CHECK(original_text ~* '^[[:alpha:]\d,.!?;"-_() ]+$'),
    FOREIGN KEY(original_language_id) REFERENCES translation.languages(id)
);

DROP TABLE IF EXISTS translation.translations CASCADE;
CREATE TABLE translation.translations(
    text_content_id BIGINT NOT NULL,
    language_id INT NOT NULL,
    content TEXT NOT NULL
        CONSTRAINT valid_translation_content CHECK(content ~* '^[[:alpha:]\d,.!?;"-_() ]+$'),
    CONSTRAINT unique_language_content UNIQUE(text_content_id, language_id),
    FOREIGN KEY(text_content_id) REFERENCES translation.text_content(id)
        ON DELETE CASCADE,
    FOREIGN KEY(language_id) REFERENCES translation.languages(id)
);

------------------------------ main schema(public) --------------------------------------------

-- TODO: find a way to keep name regex in one place(it's also used in surname, city, street constraints)

DROP TABLE IF EXISTS users CASCADE;
CREATE TABLE users(
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    login TEXT NOT NULL UNIQUE
        CONSTRAINT valid_login CHECK(login ~* '^[a-zA-Z0-9_]{4,}$'),
    role TEXT NOT NULL
        CONSTRAINT not_empty_role CHECK(length(role) > 0),
    name TEXT NOT NULL
        CONSTRAINT valid_name CHECK(name ~* '^[[:alpha:]\d-]+$'),
    surname TEXT NOT NULL
        CONSTRAINT valid_surname CHECK(surname ~* '^[[:alpha:]\d-]+$'),
    phone TEXT NOT NULL UNIQUE
        CONSTRAINT valid_phone CHECK(phone ~* '^\+?([1-9][0-9])?[0-9]{6,10}$'),
    status TEXT NOT NULL
        CONSTRAINT valid_user_status CHECK(status ~* '^[[:alpha:]]+$')
);

DROP TABLE IF EXISTS user_passwords;
CREATE TABLE user_passwords(
    user_id BIGINT NOT NULL UNIQUE,
    hash TEXT NOT NULL,           -- Hashed password with salt
    salt TEXT NOT NULL,           -- Salt used with this password
    hash_method TEXT NOT NULL,    -- Hash method identified
    FOREIGN KEY(user_id) REFERENCES users(id)
        ON DELETE CASCADE
);

DROP TABLE IF EXISTS user_accounts CASCADE;
CREATE TABLE user_accounts(
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL,
    currency TEXT NOT NULL
        CONSTRAINT not_empty_currency CHECK(length(currency) > 0),
    amount NUMERIC(12, 2) DEFAULT 0 NOT NULL
        CONSTRAINT positive_amount CHECK(amount >= 0),
    CONSTRAINT unique_user_id_currency UNIQUE(user_id, currency),
    FOREIGN KEY(user_id) REFERENCES users(id)
        ON DELETE CASCADE
);

-- Service: has characteristics(key, value)
-- Tariff plan: has services, title, price, duration, description
--
-- Service:
-- id
-- title

-- tariff plan
-- ...

-- tariff plan service
-- tariff plan id
-- service id

-- tariff plan service characteristics
-- tariff plan id
-- service id
-- name
-- value



DROP TABLE IF EXISTS services CASCADE;
CREATE TABLE services(
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name_text_content_id BIGINT UNIQUE NOT NULL,
    FOREIGN KEY(name_text_content_id) REFERENCES translation.text_content(id)
);

DROP TABLE IF EXISTS tariffs CASCADE;
CREATE TABLE tariffs(
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title_text_content_id BIGINT UNIQUE NOT NULL,           -- title
    status TEXT NOT NULL
        CONSTRAINT valid_tariff_status CHECK(status ~* '^[[:alpha:]]+$'),
    usd_price NUMERIC(12, 2) NOT NULL
        CONSTRAINT positive_usd_price CHECK(usd_price >= 0),
    FOREIGN KEY(title_text_content_id) REFERENCES translation.text_content(id)
);

DROP TABLE IF EXISTS tariff_services CASCADE;
CREATE TABLE tariff_services(
    tariff_id INT NOT NULL,
    service_id INT NOT NULL,
        -- It's unnamed, cause when rerunning the script I got 'constraint already exists' error
    -- CONSTRAINT unique_tariff_service
    UNIQUE(tariff_id, service_id),
    FOREIGN KEY(tariff_id) REFERENCES tariffs(id)
        ON DELETE CASCADE,
    FOREIGN KEY(service_id) REFERENCES services(id)
        ON DELETE CASCADE
);

-- key-value pairs describing concrete service characteristics
DROP TABLE IF EXISTS tariff_service_characteristics CASCADE;
CREATE TABLE tariff_service_characteristics(
    tariff_id INT NOT NULL,
    service_id INT NOT NULL,
    name_text_content_id BIGINT UNIQUE NOT NULL,        -- name
    value_text_content_id BIGINT UNIQUE NOT NULL,       -- value
        -- It's unnamed, cause when rerunning the script I got 'constraint already exists' error
    -- CONSTRAINT unique_tariff_service
    UNIQUE(tariff_id, service_id),
    FOREIGN KEY(tariff_id) REFERENCES tariffs(id)
        ON DELETE CASCADE,
    FOREIGN KEY(service_id) REFERENCES services(id)
        ON DELETE CASCADE,
    FOREIGN KEY(name_text_content_id) REFERENCES translation.text_content(id),
    FOREIGN KEY(value_text_content_id) REFERENCES translation.text_content(id)
);

-- Months and minutes only, for example
DROP TABLE IF EXISTS tariff_durations;
CREATE TABLE tariff_durations(
    tariff_id INT NOT NULL,
    months INT NOT NULL DEFAULT 0
        CONSTRAINT positive_duration_months CHECK(months >= 0),
    minutes BIGINT NOT NULL DEFAULT 0
        CONSTRAINT positive_duration_minutes CHECK(minutes >= 0),
    FOREIGN KEY(tariff_id) REFERENCES tariffs(id)
        ON DELETE CASCADE
);

DROP TABLE IF EXISTS users_tariffs;
CREATE TABLE users_tariffs(
    user_account_id BIGINT NOT NULL,
    tariff_id INT NOT NULL,
    subscribed_at TIMESTAMPTZ NOT NULL DEFAULT current_timestamp,
    FOREIGN KEY(user_account_id) REFERENCES user_accounts(id)
        ON DELETE CASCADE,
    FOREIGN KEY(tariff_id) REFERENCES tariffs(id)
);

END;